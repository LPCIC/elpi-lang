(* This file describes the format of the trace generated by elpi
   and the format of the elaborate trace generated by elpi-trace-elaborator

   home: https://github.com/ahrefs/atd
   doc:  https://atd.readthedocs.io/en/latest/index.html
   
   
*)

(* input: raw events  *)

type item = {
  kind : kind list;
  goal_id : int;
  runtime_id : int;
  step : int;
  name : string;
  payload : string list;
}
type kind = [ Start | Info | Stop of stop ]
type stop = { cause : string; time : float }
type raw_trace = item list

(* **** output: cards to be displayed ************************************** *)

type trace = card list

(* Note: step_id + runtime_id form a unique identified for the card *)
type card = {
  step_id : step_id;          (* sequential, but local to the runtime       *)
  runtime_id : runtime_id;    (* each runtime has an id, 0 for the main one *)
  step : step;                (* the computation step                       *)
  color : color;
}

type color = [ Red | Green | Grey | YellowGreen | YellowRed ]

type step =
  [ Inference of inference (* The goal is solved by a rule, most common case *)
  | Findall of findall     (* A sub runtime computes all solutions to a goal *)
  | Cut of cut             (* Some alternatives are dropped                  *)
  | Suspend of suspend     (* A new constraint is generated                  *)
  | Resume of resume       (* A constraint is resumed                        *)
  | CHR of chr             (* Some constraint handling rules fires           *)
  | Init of goal           (* The initial goal is set                        *)
  ]

(* Inference step operates on a goal with a bunch of rules: first a bunch of
   rules which fail, and then some which succeed. If no rule succeeds, then
   the inference fails. If a rule succeeds, but some sibling fails, then
   there may be more rules to be attempted later *)  
type inference = {
  current_goal_id : goal_id;
  current_goal_text : goal_text;
  current_goal_predicate : string; (* string to search/filter steps *)
  failed_attempts : attempt list;
  successful_attempts : successful_attempt list;
  more_successful_attempts : step_id list;
  stack : stack;
}

type attempt = {
  rule : rule;
  events : event list;
}
type rule = [ BuiltinRule of builtin_name | UserRule of user_rule ]
type user_rule = { rule_text : rule_text; rule_loc : location }
type builtin_name = [ Logic of string | FFI of string ]
type location = [ File of file_location | Context of step_id ]
type file_location = { filename : string; line : int; column : int; character : int }
type event = [ Assign of string | Fail of string | ResumeGoal of goal_id list]
type rule_text = string (* Todo: use a formattable data, e.g. box language *)

type successful_attempt = {
  attempt : attempt;
  siblings : goal list;
  siblings_aggregated_outcome : outcome;
}
type goal = { goal_text : string; goal_id : goal_id }
type outcome = [ Fail | Success ]

type stack = frame list
type frame = { rule : rule; step_id : step_id; runtime_id : runtime_id }

type goal_id = int
type step_id = int
type runtime_id = int
type goal_text = string (* Todo: use a formattable data, e.g. box language *)


(* Findall step *)
type findall = {
  findall_goal_id : goal_id;
  findall_goal_text : goal_text;
  findall_cards : trace; (* The sub trace computing all solutions to the goal *)
  findall_solution_text : solution_text;
  findall_stack : stack;
}
type solution_text = string list (* Todo: use a formattable data, e.g. box language *)

(* This goal generates a suspended sibling *)
type suspend = {
  suspend_goal_id : goal_id;
  suspend_goal_text : goal_text;
  suspend_sibling : goal;
  suspend_stack : stack;
}

(* The ! operator eliminates some rules (for some goal) *)
type cut = {
  cut_goal_id : goal_id;  
  cut_victims : cutted list;
}
type cutted = {
  cut_branch_for_goal : goal;
  cut_branch : user_rule
}

(* Resumption activaes suspended goals *)
type resume = goal list

(* A CHR step is like an inference step, it is made of some failed and some
   successful attempts. It acts on the store. *)
type chr = {
  chr_failed_attempts : chr_attempt list;
  chr_successful_attempts : successful_chr_attempt list;
  chr_store_before : goal list;
  chr_store_after : goal list;
}
type chr_attempt = {
  chr_text : chr_text;         (* the rule text *)
  chr_loc : file_location;     (* the rule loc *)
  chr_condition_cards : trace; (* the rule has a condition, which is an elpi
                                  program running in a dedicated runtime *)
}
type successful_chr_attempt = {
  chr_attempt : chr_attempt;
  chr_removed_goals : goal_id list;
  chr_new_goals : goal list;
}
type chr_text = string (* Todo: use a formattable data, e.g. box language *)
